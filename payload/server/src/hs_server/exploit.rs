use std::process::Command;
use std::thread;
use std::time::Duration;


pub fn execute_shell_script(attacker: &str, victim: &str) {

    thread::sleep(Duration::from_secs(2));

    /*let output = Command::new("/bin/sh")
        .arg("-c")
        .arg(format!("attacker=\"{}\" victim=\"{}\" {}", attacker, victim, include_str!("www/exploit.sh")))
        .output()
        .expect("failed to execute .sh");*/
    let output = Command::new("/bin/sh")
        .arg("www/exploit.sh")
        .arg(attacker)
        .arg(victim)
        .output()
        .expect("failed to execute .sh");

    println!("Script output: {:?}", String::from_utf8_lossy(&output.stdout));

    /*let file_result = OpenOptions::new().create(true).append(true).open("www/used_ip");

    match file_result {
        Ok(mut file) => match file.write_all(victim.as_bytes()) {
                Ok(_) => println!("Ok: {}: Writing finished.", victim),
                Err(..) => println!("Fail: {}: Err the file can't be writen.", victim),
        },
        Err(..) => println!("Warning: {}: No file received.", victim)
    };*/

}

